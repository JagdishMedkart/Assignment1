{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/HP/Assignment1/online-product-management/prisma/client.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\nconst globalForPrisma = global as unknown as { prisma?: PrismaClient };\r\n\r\nconst prisma = globalForPrisma.prisma || new PrismaClient();\r\n\r\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\r\n\r\nexport default prisma;\r\n"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,kBAAkB;AAExB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;AAEzD,wCAA2C,gBAAgB,MAAM,GAAG;uCAErD"}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/HP/Assignment1/online-product-management/src/app/api/products/%5BwsCode%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport prisma from \"../../../../../prisma/client\";\r\n\r\n// Helper function to delete the directory and its contents\r\nconst deleteDirectoryRecursive = (dirPath: string) => {\r\n  if (fs.existsSync(dirPath)) {\r\n    const files = fs.readdirSync(dirPath);\r\n    files.forEach((file) => {\r\n      const currentPath = path.join(dirPath, file);\r\n      if (fs.lstatSync(currentPath).isDirectory()) {\r\n        deleteDirectoryRecursive(currentPath); // Recurse into subdirectories\r\n      } else {\r\n        fs.unlinkSync(currentPath); // Delete file\r\n      }\r\n    });\r\n    fs.rmdirSync(dirPath); // Delete the directory itself\r\n  }\r\n};\r\n\r\nexport async function DELETE(\r\n  req: NextRequest,\r\n  { params }: { params: { wsCode: string } }\r\n) {\r\n  try {\r\n    // Await params to access wsCode correctly\r\n    const { wsCode } = await params; // Awaiting to access wsCode\r\n\r\n    const wsCodeNumber = Number(wsCode); // Convert to number\r\n\r\n    // Validate wsCode\r\n    if (!wsCodeNumber) {\r\n      return NextResponse.json(\r\n        { message: \"wsCode is required to delete the product\", success: false },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Check if the product exists\r\n    const product = await prisma.product.findUnique({\r\n      where: { wsCode: wsCodeNumber }, // Use the number type for wsCode\r\n    });\r\n\r\n    if (!product) {\r\n      return NextResponse.json(\r\n        {\r\n          message: `Product with wsCode ${wsCodeNumber} not found`,\r\n          success: false,\r\n        },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    // Delete images and the directory from the server\r\n    const uploadDir = path.join(\r\n      process.cwd(),\r\n      \"public\",\r\n      \"uploads\",\r\n      wsCodeNumber.toString()\r\n    );\r\n    deleteDirectoryRecursive(uploadDir); // Delete images and the folder\r\n\r\n    // Delete the product from the database\r\n    await prisma.product.delete({\r\n      where: { wsCode: wsCodeNumber }, // Use the number type for wsCode\r\n    });\r\n\r\n    return NextResponse.json(\r\n      {\r\n        message: `Product with wsCode ${wsCodeNumber} deleted successfully`,\r\n        success: true,\r\n      },\r\n      { status: 200 }\r\n    );\r\n  } catch (error) {\r\n    console.error(\"Error deleting product:\", error);\r\n    return NextResponse.json(\r\n      {\r\n        message: \"Failed to delete product\",\r\n        success: false,\r\n        error: error.message,\r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// const saveImages = async (wsCode: string, base64Images: string[]) => {\r\n//   const uploadDir = path.join(process.cwd(), \"public\", \"uploads\", wsCode.toString());\r\n  \r\n//   const imagePaths: string[] = [];\r\n//   for (const [index, base64Image] of base64Images.entries()) {\r\n//         const base64Data = base64Image.replace(/^data:image\\/\\w+;base64,/, \"\");\r\n//         const buffer = Buffer.from(base64Data, \"base64\");\r\n//         const imagePath = path.join(uploadDir, `${index + 1}.jpg`);\r\n//         fs.writeFileSync(imagePath, buffer);\r\n//         imagePaths.push(`/uploads/${wsCode}/${index + 1}.jpg`);\r\n//       }\r\n\r\n//   return imagePaths;\r\n// };\r\n\r\n// export async function PATCH(\r\n//   req: NextRequest,\r\n//   { params }: { params: { wsCode: string } }\r\n// ) {\r\n//   try {\r\n//     const { wsCode } = params;\r\n//     const wsCodeNumber = Number(wsCode);\r\n\r\n//     if (!wsCode || isNaN(wsCodeNumber)) {\r\n//       return NextResponse.json(\r\n//         { message: \"wsCode is required and must be a valid number\", success: false },\r\n//         { status: 400 }\r\n//       );\r\n//     }\r\n\r\n//     const product = await prisma.product.findUnique({\r\n//       where: { wsCode: wsCodeNumber },\r\n//     });\r\n\r\n//     if (!product) {\r\n//       return NextResponse.json(\r\n//         { message: `Product with wsCode ${wsCodeNumber} not found`, success: false },\r\n//         { status: 404 }\r\n//       );\r\n//     }\r\n\r\n//     const body = await req.json();\r\n//     const { name, mrp, packageSize, categoryId, tags, images } = body;\r\n\r\n//     if (!name  || !mrp || !packageSize || !categoryId) {\r\n//       return NextResponse.json(\r\n//         { message: \"Missing required fields\", success: false },\r\n//         { status: 400 }\r\n//       );\r\n//     }\r\n\r\n//     if (!Array.isArray(images) || images.length > 5) {\r\n//       return NextResponse.json(\r\n//         { message: \"A maximum of 5 images is allowed!\", success: false },\r\n//         { status: 400 }\r\n//       );\r\n//     }\r\n\r\n//     const imagePaths = await saveImages(wsCode, images);\r\n\r\n//     await prisma.product.update({\r\n//       where: { wsCode: wsCodeNumber },\r\n//       data: {\r\n//         name,\r\n//         // salesPrice: parseFloat(salesPrice),\r\n//         mrp: parseFloat(mrp),\r\n//         packageSize: parseFloat(packageSize),\r\n//         categoryId: parseInt(categoryId, 10),\r\n//         tags: Array.isArray(tags) ? tags : [tags],\r\n//         images: imagePaths.length > 0 ? imagePaths : undefined,\r\n//       },\r\n//     });\r\n\r\n//     return NextResponse.json(\r\n//       { message: \"Product updated successfully!\", success: true },\r\n//       { status: 200 }\r\n//     );\r\n//   } catch (error) {\r\n//     console.error(\"Error updating product:\", error);\r\n//     return NextResponse.json(\r\n//       { message: \"Failed to update product\", success: false, error: error.message },\r\n//       { status: 500 }\r\n//     );\r\n//   }\r\n// }\r\n\r\nexport async function GET(\r\n  req: NextRequest,\r\n  { params }: { params: { wsCode: string } }\r\n) {\r\n  try {\r\n    const { wsCode } = await params;\r\n    const wsCodeNumber = Number(wsCode);\r\n\r\n    if (!wsCode || isNaN(wsCodeNumber)) {\r\n      return NextResponse.json(\r\n        { message: \"wsCode is required and must be a valid number\", success: false },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    const product = await prisma.product.findUnique({\r\n      where: { wsCode: wsCodeNumber },\r\n    });\r\n\r\n    if (!product) {\r\n      return NextResponse.json(\r\n        { message: `Product with wsCode ${wsCodeNumber} not found`, success: false },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      product,\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Error fetching products:\", error);\r\n    return NextResponse.json(\r\n      { success: false, message: \"Failed to fetch products.\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n\r\n\r\nconst deleteOldImages = (wsCode: string) => {\r\n  const uploadDir = path.join(process.cwd(), \"public\", \"uploads\", wsCode);\r\n  \r\n  // Check if the directory exists\r\n  if (fs.existsSync(uploadDir)) {\r\n    const files = fs.readdirSync(uploadDir);\r\n\r\n    // Delete all the files inside the wsCode folder\r\n    for (const file of files) {\r\n      const filePath = path.join(uploadDir, file);\r\n      fs.unlinkSync(filePath); // Delete the file\r\n    }\r\n    fs.rmdirSync(uploadDir); // Remove the directory after deleting the files\r\n  }\r\n};\r\n\r\n// Helper function to save the new images\r\nconst saveImages = async (wsCode: string, base64Images: string[]) => {\r\n  const uploadDir = path.join(process.cwd(), \"public\", \"uploads\", wsCode);\r\n  \r\n  // Create the product-specific directory if it doesn't exist\r\n  if (!fs.existsSync(uploadDir)) {\r\n    fs.mkdirSync(uploadDir, { recursive: true });\r\n  }\r\n\r\n  const imagePaths: string[] = [];\r\n  \r\n  // Process and save each base64 image\r\n  for (const [index, base64Image] of base64Images.entries()) {\r\n    const base64Data = base64Image.replace(/^data:image\\/\\w+;base64,/, \"\");\r\n    const buffer = Buffer.from(base64Data, \"base64\");\r\n    const imagePath = path.join(uploadDir, `${index + 1}.jpg`);\r\n    fs.writeFileSync(imagePath, buffer); // Write the image to the file system\r\n    imagePaths.push(`/uploads/${wsCode}/${index + 1}.jpg`); // Store the path for response\r\n  }\r\n\r\n  return imagePaths;\r\n};\r\n\r\nexport async function PATCH(\r\n  req: NextRequest,\r\n  { params }: { params: { wsCode: string } }\r\n) {\r\n  try {\r\n    const { wsCode } = params;\r\n    const wsCodeNumber = Number(wsCode);\r\n\r\n    if (!wsCode || isNaN(wsCodeNumber)) {\r\n      return NextResponse.json(\r\n        { message: \"wsCode is required and must be a valid number\", success: false },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    const product = await prisma.product.findUnique({\r\n      where: { wsCode: wsCodeNumber },\r\n    });\r\n\r\n    if (!product) {\r\n      return NextResponse.json(\r\n        { message: `Product with wsCode ${wsCodeNumber} not found`, success: false },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    const body = await req.json();\r\n    const { name, mrp, packageSize, categoryId, tags, images } = body;\r\n\r\n    if (!name || !mrp || !packageSize || !categoryId) {\r\n      return NextResponse.json(\r\n        { message: \"Missing required fields\", success: false },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    if (!Array.isArray(images) || images.length > 5) {\r\n      return NextResponse.json(\r\n        { message: \"A maximum of 5 images is allowed!\", success: false },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // If new images are provided, delete the old ones and save the new ones\r\n    let imagePaths: string[] = [];\r\n    if (images.length > 0) {\r\n      // Delete old images\r\n      deleteOldImages(wsCode);\r\n      // Save new images and get their paths\r\n      imagePaths = await saveImages(wsCode, images);\r\n    }\r\n\r\n    // Update the product in the database\r\n    await prisma.product.update({\r\n      where: { wsCode: wsCodeNumber },\r\n      data: {\r\n        name,\r\n        mrp: parseFloat(mrp),\r\n        packageSize: parseFloat(packageSize),\r\n        categoryId: parseInt(categoryId, 10),\r\n        tags: Array.isArray(tags) ? tags : [tags],\r\n        images: imagePaths.length > 0 ? imagePaths : product.images, // If no new images, keep old ones\r\n      },\r\n    });\r\n\r\n    return NextResponse.json(\r\n      { message: \"Product updated successfully!\", success: true },\r\n      { status: 200 }\r\n    );\r\n  } catch (error) {\r\n    console.error(\"Error updating product:\", error);\r\n    return NextResponse.json(\r\n      { message: \"Failed to update product\", success: false, error: error.message },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,2DAA2D;AAC3D,MAAM,2BAA2B,CAAC;IAChC,IAAI,6FAAA,CAAA,UAAE,CAAC,UAAU,CAAC,UAAU;QAC1B,MAAM,QAAQ,6FAAA,CAAA,UAAE,CAAC,WAAW,CAAC;QAC7B,MAAM,OAAO,CAAC,CAAC;YACb,MAAM,cAAc,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,SAAS;YACvC,IAAI,6FAAA,CAAA,UAAE,CAAC,SAAS,CAAC,aAAa,WAAW,IAAI;gBAC3C,yBAAyB,cAAc,8BAA8B;YACvE,OAAO;gBACL,6FAAA,CAAA,UAAE,CAAC,UAAU,CAAC,cAAc,cAAc;YAC5C;QACF;QACA,6FAAA,CAAA,UAAE,CAAC,SAAS,CAAC,UAAU,8BAA8B;IACvD;AACF;AAEO,eAAe,OACpB,GAAgB,EAChB,EAAE,MAAM,EAAkC;IAE1C,IAAI;QACF,0CAA0C;QAC1C,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,QAAQ,4BAA4B;QAE7D,MAAM,eAAe,OAAO,SAAS,oBAAoB;QAEzD,kBAAkB;QAClB,IAAI,CAAC,cAAc;YACjB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAA4C,SAAS;YAAM,GACtE;gBAAE,QAAQ;YAAI;QAElB;QAEA,8BAA8B;QAC9B,MAAM,UAAU,MAAM,kHAAA,CAAA,UAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9C,OAAO;gBAAE,QAAQ;YAAa;QAChC;QAEA,IAAI,CAAC,SAAS;YACZ,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBACE,SAAS,CAAC,oBAAoB,EAAE,aAAa,UAAU,CAAC;gBACxD,SAAS;YACX,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,kDAAkD;QAClD,MAAM,YAAY,iGAAA,CAAA,UAAI,CAAC,IAAI,CACzB,QAAQ,GAAG,IACX,UACA,WACA,aAAa,QAAQ;QAEvB,yBAAyB,YAAY,+BAA+B;QAEpE,uCAAuC;QACvC,MAAM,kHAAA,CAAA,UAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YAC1B,OAAO;gBAAE,QAAQ;YAAa;QAChC;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YACE,SAAS,CAAC,oBAAoB,EAAE,aAAa,qBAAqB,CAAC;YACnE,SAAS;QACX,GACA;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,SAAS;YACT,OAAO,MAAM,OAAO;QACtB,GACA;YAAE,QAAQ;QAAI;IAElB;AACF;AAwFO,eAAe,IACpB,GAAgB,EAChB,EAAE,MAAM,EAAkC;IAE1C,IAAI;QACF,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM;QACzB,MAAM,eAAe,OAAO;QAE5B,IAAI,CAAC,UAAU,MAAM,eAAe;YAClC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAiD,SAAS;YAAM,GAC3E;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,UAAU,MAAM,kHAAA,CAAA,UAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9C,OAAO;gBAAE,QAAQ;YAAa;QAChC;QAEA,IAAI,CAAC,SAAS;YACZ,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,SAAS,CAAC,oBAAoB,EAAE,aAAa,UAAU,CAAC;gBAAE,SAAS;YAAM,GAC3E;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,SAAS;QAA4B,GACvD;YAAE,QAAQ;QAAI;IAElB;AACF;AAIA,MAAM,kBAAkB,CAAC;IACvB,MAAM,YAAY,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,UAAU,WAAW;IAEhE,gCAAgC;IAChC,IAAI,6FAAA,CAAA,UAAE,CAAC,UAAU,CAAC,YAAY;QAC5B,MAAM,QAAQ,6FAAA,CAAA,UAAE,CAAC,WAAW,CAAC;QAE7B,gDAAgD;QAChD,KAAK,MAAM,QAAQ,MAAO;YACxB,MAAM,WAAW,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,WAAW;YACtC,6FAAA,CAAA,UAAE,CAAC,UAAU,CAAC,WAAW,kBAAkB;QAC7C;QACA,6FAAA,CAAA,UAAE,CAAC,SAAS,CAAC,YAAY,gDAAgD;IAC3E;AACF;AAEA,yCAAyC;AACzC,MAAM,aAAa,OAAO,QAAgB;IACxC,MAAM,YAAY,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,UAAU,WAAW;IAEhE,4DAA4D;IAC5D,IAAI,CAAC,6FAAA,CAAA,UAAE,CAAC,UAAU,CAAC,YAAY;QAC7B,6FAAA,CAAA,UAAE,CAAC,SAAS,CAAC,WAAW;YAAE,WAAW;QAAK;IAC5C;IAEA,MAAM,aAAuB,EAAE;IAE/B,qCAAqC;IACrC,KAAK,MAAM,CAAC,OAAO,YAAY,IAAI,aAAa,OAAO,GAAI;QACzD,MAAM,aAAa,YAAY,OAAO,CAAC,4BAA4B;QACnE,MAAM,SAAS,OAAO,IAAI,CAAC,YAAY;QACvC,MAAM,YAAY,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,WAAW,GAAG,QAAQ,EAAE,IAAI,CAAC;QACzD,6FAAA,CAAA,UAAE,CAAC,aAAa,CAAC,WAAW,SAAS,qCAAqC;QAC1E,WAAW,IAAI,CAAC,CAAC,SAAS,EAAE,OAAO,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,GAAG,8BAA8B;IACxF;IAEA,OAAO;AACT;AAEO,eAAe,MACpB,GAAgB,EAChB,EAAE,MAAM,EAAkC;IAE1C,IAAI;QACF,MAAM,EAAE,MAAM,EAAE,GAAG;QACnB,MAAM,eAAe,OAAO;QAE5B,IAAI,CAAC,UAAU,MAAM,eAAe;YAClC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAiD,SAAS;YAAM,GAC3E;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,UAAU,MAAM,kHAAA,CAAA,UAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9C,OAAO;gBAAE,QAAQ;YAAa;QAChC;QAEA,IAAI,CAAC,SAAS;YACZ,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,SAAS,CAAC,oBAAoB,EAAE,aAAa,UAAU,CAAC;gBAAE,SAAS;YAAM,GAC3E;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,WAAW,EAAE,UAAU,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG;QAE7D,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,eAAe,CAAC,YAAY;YAChD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAA2B,SAAS;YAAM,GACrD;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,CAAC,MAAM,OAAO,CAAC,WAAW,OAAO,MAAM,GAAG,GAAG;YAC/C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAqC,SAAS;YAAM,GAC/D;gBAAE,QAAQ;YAAI;QAElB;QAEA,wEAAwE;QACxE,IAAI,aAAuB,EAAE;QAC7B,IAAI,OAAO,MAAM,GAAG,GAAG;YACrB,oBAAoB;YACpB,gBAAgB;YAChB,sCAAsC;YACtC,aAAa,MAAM,WAAW,QAAQ;QACxC;QAEA,qCAAqC;QACrC,MAAM,kHAAA,CAAA,UAAM,CAAC,OAAO,CAAC,MAAM,CAAC;YAC1B,OAAO;gBAAE,QAAQ;YAAa;YAC9B,MAAM;gBACJ;gBACA,KAAK,WAAW;gBAChB,aAAa,WAAW;gBACxB,YAAY,SAAS,YAAY;gBACjC,MAAM,MAAM,OAAO,CAAC,QAAQ,OAAO;oBAAC;iBAAK;gBACzC,QAAQ,WAAW,MAAM,GAAG,IAAI,aAAa,QAAQ,MAAM;YAC7D;QACF;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAiC,SAAS;QAAK,GAC1D;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAA4B,SAAS;YAAO,OAAO,MAAM,OAAO;QAAC,GAC5E;YAAE,QAAQ;QAAI;IAElB;AACF"}},
    {"offset": {"line": 332, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}