{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/HP/Assignment1/online-product-management/src/app/api/products/route.tsx"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\nimport path from \"path\";\r\nimport fs from \"fs\";\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport async function POST(req: NextRequest) {\r\n  try {\r\n    const {\r\n      name,\r\n      mrp,\r\n      packageSize,\r\n      categoryId,\r\n      tags,\r\n      images,\r\n    }: {\r\n      name: string;\r\n      mrp: number;\r\n      packageSize: number;\r\n      categoryId: number;\r\n      tags: string[];\r\n      images: string[]; // Base64 strings\r\n    } = await req.json();\r\n\r\n    // Validate required fields\r\n    if (!name || !mrp || !packageSize || !categoryId) {\r\n      return NextResponse.json(\r\n        { message: \"All fields except images and tags are required!\", success: false },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Check category existence\r\n    const categoryExists = await prisma.category.findUnique({\r\n      where: { categoryId },\r\n    });\r\n\r\n    if (!categoryExists) {\r\n      return NextResponse.json(\r\n        { message: \"Invalid category ID\", success: false },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Validate image count\r\n    if (images && images.length > 5) {\r\n      return NextResponse.json(\r\n        { message: \"A maximum of 5 images is allowed!\", success: false },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Get the next wsCode by finding the largest existing wsCode\r\n    const lastProduct = await prisma.product.findFirst({\r\n      orderBy: { wsCode: \"desc\" },\r\n      select: { wsCode: true },\r\n    });\r\n    const wsCode = lastProduct ? lastProduct.wsCode + 1 : 1;\r\n\r\n    // Create upload directory for the product\r\n    const uploadDir = path.join(process.cwd(), \"public\", \"uploads\", wsCode.toString());\r\n    if (!fs.existsSync(uploadDir)) {\r\n      fs.mkdirSync(uploadDir, { recursive: true });\r\n    }\r\n\r\n    // Save images and get paths\r\n    const imagePaths: string[] = [];\r\n    if (images) {\r\n      for (const [index, base64Image] of images.entries()) {\r\n        const base64Data = base64Image.replace(/^data:image\\/\\w+;base64,/, \"\");\r\n        const buffer = Buffer.from(base64Data, \"base64\");\r\n        const imagePath = path.join(uploadDir, `${index + 1}.jpg`); // Save images as 1.jpg, 2.jpg, etc.\r\n        fs.writeFileSync(imagePath, buffer);\r\n        imagePaths.push(`/uploads/${wsCode}/${index + 1}.jpg`);\r\n      }\r\n    }\r\n\r\n    // Insert product into the database\r\n    const newProduct = await prisma.product.create({\r\n      data: {\r\n        name,\r\n        wsCode,\r\n        mrp,\r\n        packageSize,\r\n        categoryId,\r\n        tags: tags || [],\r\n        images: imagePaths,\r\n      },\r\n    });\r\n\r\n    return NextResponse.json({\r\n      message: \"Product added successfully!\",\r\n      success: true,\r\n      product: newProduct,\r\n    });\r\n  } catch (error) {\r\n    if (error instanceof Error) {\r\n      console.error(\"Error saving product:\", error.stack);\r\n    }\r\n    return NextResponse.json(\r\n      { message: \"Failed to add product\", success: false, error: error.message },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n\r\nexport async function GET(req: NextRequest) {\r\n  try {\r\n    const { searchParams } = new URL(req.url);\r\n    const page = parseInt(searchParams.get(\"page\") || \"1\");\r\n    const limit = parseInt(searchParams.get(\"limit\") || \"5\");\r\n\r\n    // Step 1: Get all wsCode values of products\r\n    const wsCodes = await prisma.product.findMany({\r\n      select: { wsCode: true },\r\n    });\r\n\r\n    // If there are less than `limit` products, return a message\r\n    if (wsCodes.length < limit) {\r\n      return NextResponse.json({\r\n        success: false,\r\n        message: `There are less than ${limit} products available.`,\r\n      });\r\n    }\r\n\r\n    // Step 2: Randomly select `limit` number of wsCodes\r\n    const randomWsCodes = getRandomWsCodes(wsCodes, limit);\r\n\r\n    // Step 3: Fetch products using the randomly selected wsCodes\r\n    const products = await prisma.product.findMany({\r\n      where: { wsCode: { in: randomWsCodes } },\r\n    });\r\n\r\n    const total = wsCodes.length;\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      products,\r\n      total,\r\n      totalPages: Math.ceil(total / limit),\r\n      currentPage: page,\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Error fetching products:\", error);\r\n    return NextResponse.json(\r\n      { success: false, message: \"Failed to fetch products.\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// Helper function to generate random wsCodes\r\nfunction getRandomWsCodes(wsCodes: { wsCode: number }[], limit: number): number[] {\r\n  const randomWsCodes: number[] = [];\r\n  const availableWsCodes = wsCodes.map((product) => product.wsCode);\r\n\r\n  while (randomWsCodes.length < limit) {\r\n    const randomIndex = Math.floor(Math.random() * availableWsCodes.length);\r\n    const randomWsCode = availableWsCodes[randomIndex];\r\n    if (!randomWsCodes.includes(randomWsCode)) {\r\n      randomWsCodes.push(randomWsCode);\r\n    }\r\n  }\r\n\r\n  return randomWsCodes;\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,SAAS,IAAI,6HAAA,CAAA,eAAY;AAExB,eAAe,KAAK,GAAgB;IACzC,IAAI;QACF,MAAM,EACJ,IAAI,EACJ,GAAG,EACH,WAAW,EACX,UAAU,EACV,IAAI,EACJ,MAAM,EACP,GAOG,MAAM,IAAI,IAAI;QAElB,2BAA2B;QAC3B,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,eAAe,CAAC,YAAY;YAChD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAmD,SAAS;YAAM,GAC7E;gBAAE,QAAQ;YAAI;QAElB;QAEA,2BAA2B;QAC3B,MAAM,iBAAiB,MAAM,OAAO,QAAQ,CAAC,UAAU,CAAC;YACtD,OAAO;gBAAE;YAAW;QACtB;QAEA,IAAI,CAAC,gBAAgB;YACnB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAuB,SAAS;YAAM,GACjD;gBAAE,QAAQ;YAAI;QAElB;QAEA,uBAAuB;QACvB,IAAI,UAAU,OAAO,MAAM,GAAG,GAAG;YAC/B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAqC,SAAS;YAAM,GAC/D;gBAAE,QAAQ;YAAI;QAElB;QAEA,6DAA6D;QAC7D,MAAM,cAAc,MAAM,OAAO,OAAO,CAAC,SAAS,CAAC;YACjD,SAAS;gBAAE,QAAQ;YAAO;YAC1B,QAAQ;gBAAE,QAAQ;YAAK;QACzB;QACA,MAAM,SAAS,cAAc,YAAY,MAAM,GAAG,IAAI;QAEtD,0CAA0C;QAC1C,MAAM,YAAY,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,UAAU,WAAW,OAAO,QAAQ;QAC/E,IAAI,CAAC,6FAAA,CAAA,UAAE,CAAC,UAAU,CAAC,YAAY;YAC7B,6FAAA,CAAA,UAAE,CAAC,SAAS,CAAC,WAAW;gBAAE,WAAW;YAAK;QAC5C;QAEA,4BAA4B;QAC5B,MAAM,aAAuB,EAAE;QAC/B,IAAI,QAAQ;YACV,KAAK,MAAM,CAAC,OAAO,YAAY,IAAI,OAAO,OAAO,GAAI;gBACnD,MAAM,aAAa,YAAY,OAAO,CAAC,4BAA4B;gBACnE,MAAM,SAAS,OAAO,IAAI,CAAC,YAAY;gBACvC,MAAM,YAAY,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,WAAW,GAAG,QAAQ,EAAE,IAAI,CAAC,GAAG,oCAAoC;gBAChG,6FAAA,CAAA,UAAE,CAAC,aAAa,CAAC,WAAW;gBAC5B,WAAW,IAAI,CAAC,CAAC,SAAS,EAAE,OAAO,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC;YACvD;QACF;QAEA,mCAAmC;QACnC,MAAM,aAAa,MAAM,OAAO,OAAO,CAAC,MAAM,CAAC;YAC7C,MAAM;gBACJ;gBACA;gBACA;gBACA;gBACA;gBACA,MAAM,QAAQ,EAAE;gBAChB,QAAQ;YACV;QACF;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,SAAS;YACT,SAAS;QACX;IACF,EAAE,OAAO,OAAO;QACd,IAAI,iBAAiB,OAAO;YAC1B,QAAQ,KAAK,CAAC,yBAAyB,MAAM,KAAK;QACpD;QACA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAyB,SAAS;YAAO,OAAO,MAAM,OAAO;QAAC,GACzE;YAAE,QAAQ;QAAI;IAElB;AACF;AAGO,eAAe,IAAI,GAAgB;IACxC,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,IAAI,GAAG;QACxC,MAAM,OAAO,SAAS,aAAa,GAAG,CAAC,WAAW;QAClD,MAAM,QAAQ,SAAS,aAAa,GAAG,CAAC,YAAY;QAEpD,4CAA4C;QAC5C,MAAM,UAAU,MAAM,OAAO,OAAO,CAAC,QAAQ,CAAC;YAC5C,QAAQ;gBAAE,QAAQ;YAAK;QACzB;QAEA,4DAA4D;QAC5D,IAAI,QAAQ,MAAM,GAAG,OAAO;YAC1B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBACvB,SAAS;gBACT,SAAS,CAAC,oBAAoB,EAAE,MAAM,oBAAoB,CAAC;YAC7D;QACF;QAEA,oDAAoD;QACpD,MAAM,gBAAgB,iBAAiB,SAAS;QAEhD,6DAA6D;QAC7D,MAAM,WAAW,MAAM,OAAO,OAAO,CAAC,QAAQ,CAAC;YAC7C,OAAO;gBAAE,QAAQ;oBAAE,IAAI;gBAAc;YAAE;QACzC;QAEA,MAAM,QAAQ,QAAQ,MAAM;QAE5B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA;YACA,YAAY,KAAK,IAAI,CAAC,QAAQ;YAC9B,aAAa;QACf;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,SAAS;QAA4B,GACvD;YAAE,QAAQ;QAAI;IAElB;AACF;AAEA,6CAA6C;AAC7C,SAAS,iBAAiB,OAA6B,EAAE,KAAa;IACpE,MAAM,gBAA0B,EAAE;IAClC,MAAM,mBAAmB,QAAQ,GAAG,CAAC,CAAC,UAAY,QAAQ,MAAM;IAEhE,MAAO,cAAc,MAAM,GAAG,MAAO;QACnC,MAAM,cAAc,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,iBAAiB,MAAM;QACtE,MAAM,eAAe,gBAAgB,CAAC,YAAY;QAClD,IAAI,CAAC,cAAc,QAAQ,CAAC,eAAe;YACzC,cAAc,IAAI,CAAC;QACrB;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 244, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}